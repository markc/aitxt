#!/bin/bash
# aitxt â€” Discover and display ai.txt context files
# Works with both local filesystem paths and HTTP URLs
# Cascades up directory tree to find ai.txt
# Follows linked ai.txt files (depth=1) to build distributed context
# See https://aitxt.ing for the specification

set -euo pipefail

TARGET="${1:-.}"
MAX_CASCADE=10
MAX_LINKS=10
TMPDIR="${TMPDIR:-/tmp}"
VISITED_FILE="$TMPDIR/aitxt_visited_$$"
GRAPH_FILE="$TMPDIR/aitxt_graph_$$"

cleanup() {
    rm -f "$TMPDIR/aitxt_"*"_$$" 2>/dev/null || true
}
trap cleanup EXIT

# Initialize tracking files
> "$VISITED_FILE"
> "$GRAPH_FILE"

# Extract markdown links ending in ai.txt from content
extract_aitxt_links() {
    local content="$1"
    # Match [text](url) where url ends in ai.txt
    echo "$content" | grep -oE '\[[^]]*\]\([^)]*ai\.txt\)' | sed 's/.*(\([^)]*\))/\1/' || true
}

# Resolve relative path against base
resolve_path() {
    local base="$1"
    local link="$2"

    if [[ "$link" == http* ]]; then
        # Absolute URL
        echo "$link"
    elif [[ "$link" == /* ]]; then
        # Absolute filesystem path
        echo "$link"
    elif [[ "$base" == http* ]]; then
        # Relative URL - resolve against base URL
        local base_dir="${base%/*}"
        # Handle ../ and ./ in link
        while [[ "$link" == ../* ]]; do
            link="${link#../}"
            base_dir="${base_dir%/*}"
        done
        link="${link#./}"
        echo "$base_dir/$link"
    else
        # Relative filesystem path - resolve against base directory
        local base_dir="$(dirname "$base")"
        cd "$base_dir" 2>/dev/null && realpath -m "$link" 2>/dev/null || echo "$base_dir/$link"
    fi
}

# Fetch content from URL or file path
fetch_content() {
    local target="$1"
    local output_file="$2"

    if [[ "$target" == http* ]]; then
        local http_code
        http_code=$(curl -s -o "$output_file" -w "%{http_code}" "$target" 2>/dev/null || echo "000")
        [ "$http_code" = "200" ]
    else
        if [ -f "$target" ]; then
            cat "$target" > "$output_file"
            return 0
        fi
        return 1
    fi
}

# Check if already visited
is_visited() {
    grep -qxF "$1" "$VISITED_FILE" 2>/dev/null
}

# Mark as visited
mark_visited() {
    echo "$1" >> "$VISITED_FILE"
}

# Add to graph
add_to_graph() {
    local parent="$1"
    local child="$2"
    local fetched="$3"
    echo "$parent|$child|$fetched" >> "$GRAPH_FILE"
}

# Find ai.txt by cascading up
find_aitxt() {
    local target="$1"
    local depth=0

    if [[ "$target" == http* ]]; then
        local current="$target"
        while [ "$depth" -lt "$MAX_CASCADE" ]; do
            local url_path="$current/ai.txt"
            # Check if URL already ends with ai.txt
            if [[ "$current" == */ai.txt ]]; then
                url_path="$current"
            fi

            local tmp_file="$TMPDIR/aitxt_check_$$"
            if fetch_content "$url_path" "$tmp_file"; then
                echo "$url_path"
                return 0
            fi
            rm -f "$tmp_file"

            # Move to parent URL
            local parent="${current%/*}"
            [ "$parent" = "$current" ] && break
            current="$parent"
            depth=$((depth + 1))
        done
    else
        local current="$(cd "$target" 2>/dev/null && pwd || echo "$target")"
        while [ "$depth" -lt "$MAX_CASCADE" ]; do
            if [ -f "$current/ai.txt" ]; then
                echo "$current/ai.txt"
                return 0
            fi

            local parent="$(dirname "$current")"
            [ "$parent" = "$current" ] && break
            current="$parent"
            depth=$((depth + 1))
        done
    fi

    return 1
}

# Main execution
echo "ğŸ” Discovering ai.txt at: $TARGET"
echo ""

ROOT_AITXT=$(find_aitxt "$TARGET") || {
    echo "âŒ No ai.txt found in cascade"
    exit 1
}

echo "âœ… Found: $ROOT_AITXT"
echo ""

# Fetch and display root content
ROOT_CONTENT_FILE="$TMPDIR/aitxt_root_$$"
fetch_content "$ROOT_AITXT" "$ROOT_CONTENT_FILE"
cat "$ROOT_CONTENT_FILE"
echo ""
mark_visited "$ROOT_AITXT"

# Extract links from root
ROOT_LINKS=$(extract_aitxt_links "$(cat "$ROOT_CONTENT_FILE")")
LINK_COUNT=$(echo "$ROOT_LINKS" | grep -c . || echo 0)

if [ "$LINK_COUNT" -gt 0 ]; then
    echo "---"
    echo ""
    echo "ğŸ“ Following $LINK_COUNT linked context(s)..."
    echo ""

    FOLLOWED=0
    DEPTH1_LINKS=""

    while IFS= read -r link; do
        [ -z "$link" ] && continue
        [ "$FOLLOWED" -ge "$MAX_LINKS" ] && {
            echo "âš ï¸  Link limit reached ($MAX_LINKS), skipping remaining..."
            break
        }

        # Resolve relative links
        resolved=$(resolve_path "$ROOT_AITXT" "$link")

        # Skip if already visited
        if is_visited "$resolved"; then
            continue
        fi

        mark_visited "$resolved"

        # Fetch linked ai.txt
        LINK_CONTENT_FILE="$TMPDIR/aitxt_link_${FOLLOWED}_$$"
        if fetch_content "$resolved" "$LINK_CONTENT_FILE"; then
            echo "--- $resolved ---"
            echo ""
            cat "$LINK_CONTENT_FILE"
            echo ""
            add_to_graph "$ROOT_AITXT" "$resolved" "âœ“"

            # Extract depth-2 links (record but don't fetch)
            DEPTH2_LINKS=$(extract_aitxt_links "$(cat "$LINK_CONTENT_FILE")")
            while IFS= read -r d2link; do
                [ -z "$d2link" ] && continue
                d2resolved=$(resolve_path "$resolved" "$d2link")
                if ! is_visited "$d2resolved" && ! grep -q "|$d2resolved|" "$GRAPH_FILE" 2>/dev/null; then
                    add_to_graph "$resolved" "$d2resolved" " "
                fi
            done <<< "$DEPTH2_LINKS"

            FOLLOWED=$((FOLLOWED + 1))
        else
            echo "âš ï¸  Could not fetch: $resolved"
            add_to_graph "$ROOT_AITXT" "$resolved" "âœ—"
        fi
    done <<< "$ROOT_LINKS"
fi

# Display graph if we have linked contexts
if [ -s "$GRAPH_FILE" ]; then
    echo "---"
    echo ""
    echo "ğŸ“Š Discovered ai.txt graph:"
    echo "â”œâ”€â”€ $ROOT_AITXT (root)"

    # Show depth-1 links
    grep "^$ROOT_AITXT|" "$GRAPH_FILE" 2>/dev/null | while IFS='|' read -r parent child status; do
        echo "â”‚   â”œâ”€â”€ $child $status"
        # Show depth-2 links under this child
        grep "^$child|" "$GRAPH_FILE" 2>/dev/null | while IFS='|' read -r p2 c2 s2; do
            echo "â”‚   â”‚   â””â”€â”€ $c2 (not fetched)"
        done || true
    done || true

    echo ""
    echo "ğŸ’¡ Run 'aitxt <url>' to explore unfetched contexts"
fi

echo ""
echo "---"
echo "ğŸ“ Root: $ROOT_AITXT"
